// acorn-walk.umd.min.js
(function(global) {
  var exports = {};
function simple(e, n, r, o, i) {
    r || (r = t);
    (function c(e, t, o) {
        var i = o || e.type
          , a = n[i];
        r[i](e, t, c);
        a && a(e, t)
    }
    )(e, o, i)
}
function ancestor(e, n, r, o, i) {
    var a = [];
    r || (r = t);
    (function c(e, t, o) {
        var i = o || e.type
          , s = n[i];
        var u = e !== a[a.length - 1];
        u && a.push(e);
        r[i](e, t, c);
        s && s(e, t || a, a);
        u && a.pop()
    }
    )(e, o, i)
}
function recursive(e, t, n, r, o) {
    var i = n ? make(n, r || void 0) : r;
    (function c(e, t, n) {
        i[n || e.type](e, t, c)
    }
    )(e, t, o)
}
function makeTest(e) {
    return "string" === typeof e ? function(t) {
        return t === e
    }
    : e || function() {
        return true
    }
}
var e = function Found(e, t) {
    this.node = e;
    this.state = t
};
function full(e, n, r, o, i) {
    r || (r = t);
    var a;
    (function c(e, t, o) {
        var i = o || e.type;
        r[i](e, t, c);
        if (a !== e) {
            n(e, t, i);
            a = e
        }
    }
    )(e, o, i)
}
function fullAncestor(e, n, r, o) {
    r || (r = t);
    var i, a = [];
    (function c(e, t, o) {
        var s = o || e.type;
        var u = e !== a[a.length - 1];
        u && a.push(e);
        r[s](e, t, c);
        if (i !== e) {
            n(e, t || a, a, s);
            i = e
        }
        u && a.pop()
    }
    )(e, o)
}
function findNodeAt(n, r, o, i, a, s) {
    a || (a = t);
    i = makeTest(i);
    try {
        (function c(t, n, s) {
            var u = s || t.type;
            (null == r || t.start <= r) && (null == o || t.end >= o) && a[u](t, n, c);
            if ((null == r || t.start === r) && (null == o || t.end === o) && i(u, t))
                throw new e(t,n)
        }
        )(n, s)
    } catch (t) {
        if (t instanceof e)
            return t;
        throw t
    }
}
function findNodeAround(n, r, o, i, a) {
    o = makeTest(o);
    i || (i = t);
    try {
        (function c(t, n, a) {
            var s = a || t.type;
            if (!(t.start > r || t.end < r)) {
                i[s](t, n, c);
                if (o(s, t))
                    throw new e(t,n)
            }
        }
        )(n, a)
    } catch (t) {
        if (t instanceof e)
            return t;
        throw t
    }
}
function findNodeAfter(n, r, o, i, a) {
    o = makeTest(o);
    i || (i = t);
    try {
        (function c(t, n, a) {
            if (!(t.end < r)) {
                var s = a || t.type;
                if (t.start >= r && o(s, t))
                    throw new e(t,n);
                i[s](t, n, c)
            }
        }
        )(n, a)
    } catch (t) {
        if (t instanceof e)
            return t;
        throw t
    }
}
function findNodeBefore(n, r, o, i, a) {
    o = makeTest(o);
    i || (i = t);
    var s;
    (function c(t, n, a) {
        if (!(t.start > r)) {
            var u = a || t.type;
            t.end <= r && (!s || s.node.end < t.end) && o(u, t) && (s = new e(t,n));
            i[u](t, n, c)
        }
    }
    )(n, a);
    return s
}
function make(e, n) {
    var r = Object.create(n || t);
    for (var o in e)
        r[o] = e[o];
    return r
}
function skipThrough(e, t, n) {
    n(e, t)
}
function ignore(e, t, n) {}
var t = {};
t.Program = t.BlockStatement = t.StaticBlock = function(e, t, n) {
    for (var r = 0, o = e.body; r < o.length; r += 1) {
        var i = o[r];
        n(i, t, "Statement")
    }
}
;
t.Statement = skipThrough;
t.EmptyStatement = ignore;
t.ExpressionStatement = t.ParenthesizedExpression = t.ChainExpression = function(e, t, n) {
    return n(e.expression, t, "Expression")
}
;
t.IfStatement = function(e, t, n) {
    n(e.test, t, "Expression");
    n(e.consequent, t, "Statement");
    e.alternate && n(e.alternate, t, "Statement")
}
;
t.LabeledStatement = function(e, t, n) {
    return n(e.body, t, "Statement")
}
;
t.BreakStatement = t.ContinueStatement = ignore;
t.WithStatement = function(e, t, n) {
    n(e.object, t, "Expression");
    n(e.body, t, "Statement")
}
;
t.SwitchStatement = function(e, t, n) {
    n(e.discriminant, t, "Expression");
    for (var r = 0, o = e.cases; r < o.length; r += 1) {
        var i = o[r];
        i.test && n(i.test, t, "Expression");
        for (var a = 0, s = i.consequent; a < s.length; a += 1) {
            var u = s[a];
            n(u, t, "Statement")
        }
    }
}
;
t.SwitchCase = function(e, t, n) {
    e.test && n(e.test, t, "Expression");
    for (var r = 0, o = e.consequent; r < o.length; r += 1) {
        var i = o[r];
        n(i, t, "Statement")
    }
}
;
t.ReturnStatement = t.YieldExpression = t.AwaitExpression = function(e, t, n) {
    e.argument && n(e.argument, t, "Expression")
}
;
t.ThrowStatement = t.SpreadElement = function(e, t, n) {
    return n(e.argument, t, "Expression")
}
;
t.TryStatement = function(e, t, n) {
    n(e.block, t, "Statement");
    e.handler && n(e.handler, t);
    e.finalizer && n(e.finalizer, t, "Statement")
}
;
t.CatchClause = function(e, t, n) {
    e.param && n(e.param, t, "Pattern");
    n(e.body, t, "Statement")
}
;
t.WhileStatement = t.DoWhileStatement = function(e, t, n) {
    n(e.test, t, "Expression");
    n(e.body, t, "Statement")
}
;
t.ForStatement = function(e, t, n) {
    e.init && n(e.init, t, "ForInit");
    e.test && n(e.test, t, "Expression");
    e.update && n(e.update, t, "Expression");
    n(e.body, t, "Statement")
}
;
t.ForInStatement = t.ForOfStatement = function(e, t, n) {
    n(e.left, t, "ForInit");
    n(e.right, t, "Expression");
    n(e.body, t, "Statement")
}
;
t.ForInit = function(e, t, n) {
    "VariableDeclaration" === e.type ? n(e, t) : n(e, t, "Expression")
}
;
t.DebuggerStatement = ignore;
t.FunctionDeclaration = function(e, t, n) {
    return n(e, t, "Function")
}
;
t.VariableDeclaration = function(e, t, n) {
    for (var r = 0, o = e.declarations; r < o.length; r += 1) {
        var i = o[r];
        n(i, t)
    }
}
;
t.VariableDeclarator = function(e, t, n) {
    n(e.id, t, "Pattern");
    e.init && n(e.init, t, "Expression")
}
;
t.Function = function(e, t, n) {
    e.id && n(e.id, t, "Pattern");
    for (var r = 0, o = e.params; r < o.length; r += 1) {
        var i = o[r];
        n(i, t, "Pattern")
    }
    n(e.body, t, e.expression ? "Expression" : "Statement")
}
;
t.Pattern = function(e, t, n) {
    "Identifier" === e.type ? n(e, t, "VariablePattern") : "MemberExpression" === e.type ? n(e, t, "MemberPattern") : n(e, t)
}
;
t.VariablePattern = ignore;
t.MemberPattern = skipThrough;
t.RestElement = function(e, t, n) {
    return n(e.argument, t, "Pattern")
}
;
t.ArrayPattern = function(e, t, n) {
    for (var r = 0, o = e.elements; r < o.length; r += 1) {
        var i = o[r];
        i && n(i, t, "Pattern")
    }
}
;
t.ObjectPattern = function(e, t, n) {
    for (var r = 0, o = e.properties; r < o.length; r += 1) {
        var i = o[r];
        if ("Property" === i.type) {
            i.computed && n(i.key, t, "Expression");
            n(i.value, t, "Pattern")
        } else
            "RestElement" === i.type && n(i.argument, t, "Pattern")
    }
}
;
t.Expression = skipThrough;
t.ThisExpression = t.Super = t.MetaProperty = ignore;
t.ArrayExpression = function(e, t, n) {
    for (var r = 0, o = e.elements; r < o.length; r += 1) {
        var i = o[r];
        i && n(i, t, "Expression")
    }
}
;
t.ObjectExpression = function(e, t, n) {
    for (var r = 0, o = e.properties; r < o.length; r += 1) {
        var i = o[r];
        n(i, t)
    }
}
;
t.FunctionExpression = t.ArrowFunctionExpression = t.FunctionDeclaration;
t.SequenceExpression = function(e, t, n) {
    for (var r = 0, o = e.expressions; r < o.length; r += 1) {
        var i = o[r];
        n(i, t, "Expression")
    }
}
;
t.TemplateLiteral = function(e, t, n) {
    for (var r = 0, o = e.quasis; r < o.length; r += 1) {
        var i = o[r];
        n(i, t)
    }
    for (var a = 0, s = e.expressions; a < s.length; a += 1) {
        var u = s[a];
        n(u, t, "Expression")
    }
}
;
t.TemplateElement = ignore;
t.UnaryExpression = t.UpdateExpression = function(e, t, n) {
    n(e.argument, t, "Expression")
}
;
t.BinaryExpression = t.LogicalExpression = function(e, t, n) {
    n(e.left, t, "Expression");
    n(e.right, t, "Expression")
}
;
t.AssignmentExpression = t.AssignmentPattern = function(e, t, n) {
    n(e.left, t, "Pattern");
    n(e.right, t, "Expression")
}
;
t.ConditionalExpression = function(e, t, n) {
    n(e.test, t, "Expression");
    n(e.consequent, t, "Expression");
    n(e.alternate, t, "Expression")
}
;
t.NewExpression = t.CallExpression = function(e, t, n) {
    n(e.callee, t, "Expression");
    if (e.arguments)
        for (var r = 0, o = e.arguments; r < o.length; r += 1) {
            var i = o[r];
            n(i, t, "Expression")
        }
}
;
t.MemberExpression = function(e, t, n) {
    n(e.object, t, "Expression");
    e.computed && n(e.property, t, "Expression")
}
;
t.ExportNamedDeclaration = t.ExportDefaultDeclaration = function(e, t, n) {
    e.declaration && n(e.declaration, t, "ExportNamedDeclaration" === e.type || e.declaration.id ? "Statement" : "Expression");
    e.source && n(e.source, t, "Expression")
}
;
t.ExportAllDeclaration = function(e, t, n) {
    e.exported && n(e.exported, t);
    n(e.source, t, "Expression")
}
;
t.ImportDeclaration = function(e, t, n) {
    for (var r = 0, o = e.specifiers; r < o.length; r += 1) {
        var i = o[r];
        n(i, t)
    }
    n(e.source, t, "Expression")
}
;
t.ImportExpression = function(e, t, n) {
    n(e.source, t, "Expression")
}
;
t.ImportSpecifier = t.ImportDefaultSpecifier = t.ImportNamespaceSpecifier = t.Identifier = t.PrivateIdentifier = t.Literal = ignore;
t.TaggedTemplateExpression = function(e, t, n) {
    n(e.tag, t, "Expression");
    n(e.quasi, t, "Expression")
}
;
t.ClassDeclaration = t.ClassExpression = function(e, t, n) {
    return n(e, t, "Class")
}
;
t.Class = function(e, t, n) {
    e.id && n(e.id, t, "Pattern");
    e.superClass && n(e.superClass, t, "Expression");
    n(e.body, t)
}
;
t.ClassBody = function(e, t, n) {
    for (var r = 0, o = e.body; r < o.length; r += 1) {
        var i = o[r];
        n(i, t)
    }
}
;
t.MethodDefinition = t.PropertyDefinition = t.Property = function(e, t, n) {
    e.computed && n(e.key, t, "Expression");
    e.value && n(e.value, t, "Expression")
}
;
  
  global.acornWalk = {
    simple,
    ancestor,
    recursive,
    full,
    fullAncestor,
    findNodeAt,
    findNodeAround,
    findNodeBefore,
    findNodeAfter,
    make,
    base
  };
})(this);
